/**
 * rar-stream - Node.js wrapper with Readable stream support
 * 
 * This module wraps the native NAPI bindings to provide Node.js Readable streams
 * for streaming file content from RAR archives.
 * 
 * Supports both native LocalFileMedia and custom FileMedia implementations
 * (like WebTorrent files).
 */

import { Readable } from 'stream';
import { createRequire } from 'module';

// Import native bindings (CommonJS, auto-generated by NAPI-RS)
const require = createRequire(import.meta.url);
const native = require('../index.js');
const {
  LocalFileMedia: NativeLocalFileMedia,
  InnerFile: NativeInnerFile,
  RarFilesPackage: NativeRarFilesPackage,
  parseRarHeader,
  isRarArchive,
} = native;

// Re-export utility functions
export { parseRarHeader, isRarArchive };

// RAR signatures
const RAR4_SIGNATURE = Buffer.from([0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x00]);
const RAR5_SIGNATURE = Buffer.from([0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x01, 0x00]);

/**
 * Check if a file is a native LocalFileMedia
 */
function isNativeMedia(file) {
  return file._native instanceof NativeLocalFileMedia || 
         file instanceof NativeLocalFileMedia ||
         (file._nativeMedia && file._nativeMedia instanceof NativeLocalFileMedia);
}

/**
 * LocalFileMedia - reads from local filesystem.
 * Wraps the native implementation with stream support.
 */
export class LocalFileMedia {
  constructor(path) {
    this._native = new NativeLocalFileMedia(path);
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Read a byte range and return as Buffer.
   * @param {{ start: number, end: number }} opts - Byte range (inclusive)
   * @returns {Promise<Buffer>}
   */
  async createReadStream(opts) {
    return this._native.createReadStream(opts);
  }

  /**
   * Get a Node.js Readable stream for a byte range.
   * @param {{ start: number, end: number, highWaterMark?: number }} opts
   * @returns {Readable}
   */
  getReadableStream(opts) {
    const { start, end, highWaterMark = 64 * 1024 } = opts;
    const media = this._native;
    let offset = start;

    return new Readable({
      highWaterMark,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          const chunk = await media.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }

  /** @internal */
  get _nativeMedia() {
    return this._native;
  }
}

/**
 * InnerFile - a file inside the RAR archive.
 * Wraps the native implementation with stream support.
 */
export class InnerFile {
  constructor(nativeInnerFile) {
    this._native = nativeInnerFile;
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Read a byte range and return as Buffer.
   * @param {{ start: number, end: number }} opts - Byte range (inclusive)
   * @returns {Promise<Buffer>}
   */
  async createReadStream(opts) {
    return this._native.createReadStream(opts);
  }

  /**
   * Read entire file into memory.
   * @returns {Promise<Buffer>}
   */
  async readToEnd() {
    return this._native.readToEnd();
  }

  /**
   * Get a Node.js Readable stream for the entire file or a byte range.
   * 
   * @param {{ start?: number, end?: number, highWaterMark?: number }} [opts]
   * @returns {Readable}
   * 
   * @example
   * // Stream entire file
   * const stream = file.getReadableStream();
   * stream.pipe(fs.createWriteStream('output.bin'));
   * 
   * @example
   * // Stream a specific range
   * const stream = file.getReadableStream({ start: 0, end: 1024 * 1024 - 1 });
   * 
   * @example
   * // Use with WebTorrent or HTTP range requests
   * const stream = file.getReadableStream({ start: req.start, end: req.end });
   * stream.pipe(res);
   */
  getReadableStream(opts = {}) {
    const start = opts.start ?? 0;
    const end = opts.end ?? this.length - 1;
    const highWaterMark = opts.highWaterMark ?? 64 * 1024;
    const innerFile = this._native;
    let offset = start;

    return new Readable({
      highWaterMark,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          const chunk = await innerFile.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }
}

/**
 * JsInnerFile - a file inside the RAR archive (JS-based implementation).
 * Used when parsing with custom FileMedia implementations.
 */
class JsInnerFile {
  constructor(opts) {
    this._name = opts.name;
    this._length = opts.unpackedSize;
    this._packedSize = opts.packedSize;
    this._method = opts.method;
    this._dataOffset = opts.dataOffset;
    this._media = opts.media;
    this._isStored = opts.method === 0x30;
  }

  get name() {
    return this._name;
  }

  get length() {
    return this._length;
  }

  /**
   * Read a byte range and return as Buffer.
   * Note: Only works for stored files (method 0x30). Compressed files
   * require full decompression.
   */
  async createReadStream(opts) {
    const { start, end } = opts;
    
    if (!this._isStored) {
      // For compressed files, we need to decompress the entire file
      // and then slice the result
      throw new Error('Range reads not supported for compressed files. Use readToEnd() instead.');
    }
    
    // For stored files, read directly from the RAR data
    const dataStart = this._dataOffset + start;
    const dataEnd = this._dataOffset + end;
    return this._media.createReadStream({ start: dataStart, end: dataEnd });
  }

  /**
   * Read entire file into memory.
   */
  async readToEnd() {
    if (this._isStored) {
      // Stored file - read raw data
      return this._media.createReadStream({
        start: this._dataOffset,
        end: this._dataOffset + this._length - 1,
      });
    } else {
      // Compressed file - need to decompress
      // Read packed data
      const packedData = await this._media.createReadStream({
        start: this._dataOffset,
        end: this._dataOffset + this._packedSize - 1,
      });
      
      // TODO: Add decompression support using WasmRarDecoder
      // For now, throw an error
      throw new Error('Decompression not yet implemented for JS FileMedia. Use stored archives (rar -m0).');
    }
  }

  /**
   * Get a Node.js Readable stream for the entire file or a byte range.
   */
  getReadableStream(opts = {}) {
    const start = opts.start ?? 0;
    const end = opts.end ?? this.length - 1;
    const highWaterMark = opts.highWaterMark ?? 64 * 1024;
    const file = this;
    let offset = start;

    if (!this._isStored) {
      // For compressed files, we'd need streaming decompression
      // For now, return a stream that reads the entire file first
      const self = this;
      let buffer = null;
      let bufferOffset = 0;
      
      return new Readable({
        highWaterMark,
        async read(size) {
          try {
            if (!buffer) {
              buffer = await self.readToEnd();
            }
            if (bufferOffset >= buffer.length) {
              this.push(null);
              return;
            }
            const chunk = buffer.slice(bufferOffset, bufferOffset + size);
            bufferOffset += chunk.length;
            this.push(chunk);
          } catch (err) {
            this.destroy(err);
          }
        },
      });
    }

    return new Readable({
      highWaterMark,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          const chunk = await file.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }
}

/**
 * RarFilesPackage - parses multi-volume RAR archives.
 * 
 * Supports both native LocalFileMedia and custom FileMedia implementations
 * (like WebTorrent files). Custom implementations must have:
 * - name: string
 * - length: number
 * - createReadStream({ start, end }): Promise<Buffer>
 */
export class RarFilesPackage {
  constructor(files) {
    this._files = files;
    this._useNative = files.every(f => isNativeMedia(f));
    
    if (this._useNative) {
      const nativeFiles = files.map(f => f._nativeMedia ?? f._native ?? f);
      this._native = new NativeRarFilesPackage(nativeFiles);
    }
  }

  /**
   * Parse the archive and return inner files.
   * @param {{ maxFiles?: number }} [opts]
   * @returns {Promise<InnerFile[]>}
   */
  async parse(opts) {
    if (this._useNative) {
      const nativeFiles = await this._native.parse(opts);
      return nativeFiles.map(f => new InnerFile(f));
    }
    
    // JS-based parsing for custom FileMedia
    return this._parseJs(opts);
  }
  
  /**
   * JS-based parsing for custom FileMedia implementations.
   * @private
   */
  async _parseJs(opts) {
    const maxFiles = opts?.maxFiles;
    const results = [];
    
    for (const media of this._files) {
      // Read header data (first 512 bytes should be enough for header)
      const headerSize = Math.min(512, media.length);
      const headerData = await media.createReadStream({ start: 0, end: headerSize - 1 });
      
      // Check signature
      if (!isRarArchive(headerData)) {
        continue;
      }
      
      // Determine RAR version
      const isRar5 = headerData.slice(0, 8).equals(RAR5_SIGNATURE);
      
      // Parse header to get file info
      const header = parseRarHeader(headerData);
      if (!header) {
        continue;
      }
      
      // Calculate data offset (approximate - after headers)
      // For RAR4: marker(7) + archive(13) + file header (variable)
      // For RAR5: signature(8) + headers (variable length)
      const dataOffset = media.length - header.packedSize;
      
      results.push(new JsInnerFile({
        name: header.name,
        packedSize: header.packedSize,
        unpackedSize: header.unpackedSize,
        method: header.method,
        dataOffset,
        media,
      }));
      
      if (maxFiles && results.length >= maxFiles) {
        break;
      }
    }
    
    return results;
  }
}
