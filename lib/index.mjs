/**
 * rar-stream - Node.js wrapper with Readable stream support
 * 
 * This module wraps the native NAPI bindings to provide Node.js Readable streams
 * for streaming file content from RAR archives.
 */

import { Readable } from 'stream';
import { createRequire } from 'module';

// Import native bindings (CommonJS, auto-generated by NAPI-RS)
const require = createRequire(import.meta.url);
const native = require('../index.js');
const {
  LocalFileMedia: NativeLocalFileMedia,
  InnerFile: NativeInnerFile,
  RarFilesPackage: NativeRarFilesPackage,
  parseRarHeader,
  isRarArchive,
} = native;

// Re-export utility functions
export { parseRarHeader, isRarArchive };

/**
 * LocalFileMedia - reads from local filesystem.
 * Wraps the native implementation with stream support.
 */
export class LocalFileMedia {
  constructor(path) {
    this._native = new NativeLocalFileMedia(path);
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Read a byte range and return as Buffer.
   * @param {{ start: number, end: number }} opts - Byte range (inclusive)
   * @returns {Promise<Buffer>}
   */
  async createReadStream(opts) {
    return this._native.createReadStream(opts);
  }

  /**
   * Get a Node.js Readable stream for a byte range.
   * @param {{ start: number, end: number, highWaterMark?: number }} opts
   * @returns {Readable}
   */
  getReadableStream(opts) {
    const { start, end, highWaterMark = 64 * 1024 } = opts;
    const media = this._native;
    let offset = start;

    return new Readable({
      highWaterMark,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          const chunk = await media.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }

  /** @internal */
  get _nativeMedia() {
    return this._native;
  }
}

/**
 * InnerFile - a file inside the RAR archive.
 * Wraps the native implementation with stream support.
 */
export class InnerFile {
  constructor(nativeInnerFile) {
    this._native = nativeInnerFile;
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Read a byte range and return as Buffer.
   * @param {{ start: number, end: number }} opts - Byte range (inclusive)
   * @returns {Promise<Buffer>}
   */
  async createReadStream(opts) {
    return this._native.createReadStream(opts);
  }

  /**
   * Read entire file into memory.
   * @returns {Promise<Buffer>}
   */
  async readToEnd() {
    return this._native.readToEnd();
  }

  /**
   * Get a Node.js Readable stream for the entire file or a byte range.
   * 
   * @param {{ start?: number, end?: number, highWaterMark?: number }} [opts]
   * @returns {Readable}
   * 
   * @example
   * // Stream entire file
   * const stream = file.getReadableStream();
   * stream.pipe(fs.createWriteStream('output.bin'));
   * 
   * @example
   * // Stream a specific range
   * const stream = file.getReadableStream({ start: 0, end: 1024 * 1024 - 1 });
   * 
   * @example
   * // Use with WebTorrent or HTTP range requests
   * const stream = file.getReadableStream({ start: req.start, end: req.end });
   * stream.pipe(res);
   */
  getReadableStream(opts = {}) {
    const start = opts.start ?? 0;
    const end = opts.end ?? this.length - 1;
    const highWaterMark = opts.highWaterMark ?? 64 * 1024;
    const innerFile = this._native;
    let offset = start;

    return new Readable({
      highWaterMark,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          const chunk = await innerFile.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }
}

/**
 * RarFilesPackage - parses multi-volume RAR archives.
 * Wraps the native implementation.
 */
export class RarFilesPackage {
  constructor(files) {
    // Extract native media objects
    const nativeFiles = files.map(f => f._nativeMedia ?? f._native ?? f);
    this._native = new NativeRarFilesPackage(nativeFiles);
  }

  /**
   * Parse the archive and return inner files.
   * @param {{ maxFiles?: number }} [opts]
   * @returns {Promise<InnerFile[]>}
   */
  async parse(opts) {
    const nativeFiles = await this._native.parse(opts);
    return nativeFiles.map(f => new InnerFile(f));
  }
}
