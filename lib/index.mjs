/**
 * rar-stream - Node.js wrapper with Readable stream support
 * 
 * This module wraps the native NAPI bindings to provide Node.js Readable streams
 * for streaming file content from RAR archives.
 * 
 * Supports both native LocalFileMedia and custom FileMedia implementations
 * (like WebTorrent files).
 */

import { Readable } from 'stream';
import { createRequire } from 'module';

// Import native bindings (CommonJS, auto-generated by NAPI-RS)
const require = createRequire(import.meta.url);
const native = require('../index.js');
const {
  LocalFileMedia: NativeLocalFileMedia,
  InnerFile: NativeInnerFile,
  RarFilesPackage: NativeRarFilesPackage,
  parseRarHeader,
  isRarArchive,
} = native;

// Re-export utility functions
export { parseRarHeader, isRarArchive };

// RAR signatures
const RAR4_SIGNATURE = Buffer.from([0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x00]);
const RAR5_SIGNATURE = Buffer.from([0x52, 0x61, 0x72, 0x21, 0x1A, 0x07, 0x01, 0x00]);

/**
 * Helper to read a Readable stream into a Buffer.
 * @param {Readable} stream
 * @returns {Promise<Buffer>}
 */
export function streamToBuffer(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on('data', chunk => chunks.push(chunk));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
    stream.on('error', reject);
  });
}

/**
 * Check if a file is a native LocalFileMedia
 */
function isNativeMedia(file) {
  return file._native instanceof NativeLocalFileMedia || 
         file instanceof NativeLocalFileMedia ||
         (file._nativeMedia && file._nativeMedia instanceof NativeLocalFileMedia);
}

/**
 * Create a FileMedia wrapper from any object with createReadStream.
 * 
 * Use this to wrap WebTorrent files, HTTP responses, S3 objects, etc.
 * The wrapped object must have:
 * - name: string
 * - length: number  
 * - createReadStream({ start, end }): Readable
 * 
 * @param {Object} source - Object implementing FileMedia interface
 * @returns {FileMedia}
 * 
 * @example
 * // Wrap a WebTorrent file
 * const media = createFileMedia({
 *   name: torrentFile.name,
 *   length: torrentFile.length,
 *   createReadStream: (opts) => torrentFile.createReadStream(opts),
 * });
 * const pkg = new RarFilesPackage([media]);
 */
export function createFileMedia(source) {
  return {
    get name() { return source.name; },
    get length() { return source.length; },
    createReadStream(opts) {
      return source.createReadStream(opts);
    },
  };
}

/**
 * LocalFileMedia - reads from local filesystem.
 * Implements the FileMedia interface.
 */
export class LocalFileMedia {
  constructor(path) {
    this._native = new NativeLocalFileMedia(path);
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Create a Readable stream for a byte range.
   * @param {{ start: number, end: number }} opts - Byte range (inclusive)
   * @returns {Readable}
   */
  createReadStream(opts) {
    const { start, end } = opts;
    const media = this._native;
    let offset = start;

    return new Readable({
      highWaterMark: 64 * 1024,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          // Native returns Promise<Buffer>, we stream it
          const chunk = await media.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }

  /** @internal */
  get _nativeMedia() {
    return this._native;
  }
}

/**
 * InnerFile - a file inside the RAR archive.
 * Wraps the native implementation with stream support.
 */
export class InnerFile {
  constructor(nativeInnerFile) {
    this._native = nativeInnerFile;
  }

  get name() {
    return this._native.name;
  }

  get length() {
    return this._native.length;
  }

  /**
   * Create a Readable stream for a byte range or entire file.
   * @param {{ start?: number, end?: number }} [opts] - Byte range (inclusive)
   * @returns {Readable}
   * 
   * @example
   * // Stream entire file
   * const stream = file.createReadStream();
   * stream.pipe(fs.createWriteStream('output.bin'));
   * 
   * @example
   * // Stream a specific range (for HTTP range requests)
   * const stream = file.createReadStream({ start: 0, end: 1024 * 1024 - 1 });
   * stream.pipe(res);
   */
  createReadStream(opts = {}) {
    const start = opts.start ?? 0;
    const end = opts.end ?? this.length - 1;
    const innerFile = this._native;
    let offset = start;

    return new Readable({
      highWaterMark: 64 * 1024,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          // Native returns Promise<Buffer>
          const chunk = await innerFile.createReadStream({ start: offset, end: chunkEnd });
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }

  /**
   * Read entire file into memory.
   * @returns {Promise<Buffer>}
   */
  async readToEnd() {
    return this._native.readToEnd();
  }
}

/**
 * JsInnerFile - a file inside the RAR archive (JS-based implementation).
 * Used when parsing with custom FileMedia implementations.
 */
class JsInnerFile {
  constructor(opts) {
    this._name = opts.name;
    this._length = opts.unpackedSize;
    this._packedSize = opts.packedSize;
    this._method = opts.method;
    this._dataOffset = opts.dataOffset;
    this._media = opts.media;
    this._isStored = opts.method === 0x30;
  }

  get name() {
    return this._name;
  }

  get length() {
    return this._length;
  }

  /**
   * Create a Readable stream for a byte range or entire file.
   * Note: Range reads only work for stored files (method 0x30).
   * Compressed files require full decompression.
   * 
   * @param {{ start?: number, end?: number }} [opts]
   * @returns {Readable}
   */
  createReadStream(opts = {}) {
    const start = opts.start ?? 0;
    const end = opts.end ?? this.length - 1;
    const file = this;

    if (!this._isStored) {
      // For compressed files, throw an error for range reads
      if (start !== 0 || end !== this.length - 1) {
        throw new Error('Range reads not supported for compressed files. Use readToEnd() instead.');
      }
      // TODO: streaming decompression
      throw new Error('Streaming compressed files not yet supported for custom FileMedia.');
    }

    // For stored files, stream directly from the source
    const dataOffset = this._dataOffset;
    const media = this._media;
    let offset = start;

    return new Readable({
      highWaterMark: 64 * 1024,
      async read(size) {
        if (offset > end) {
          this.push(null);
          return;
        }
        const chunkEnd = Math.min(offset + size - 1, end);
        try {
          // Get stream from underlying media and collect it
          const dataStart = dataOffset + offset;
          const dataEnd = dataOffset + chunkEnd;
          const sourceStream = media.createReadStream({ start: dataStart, end: dataEnd });
          const chunk = await streamToBuffer(sourceStream);
          offset = chunkEnd + 1;
          this.push(chunk);
        } catch (err) {
          this.destroy(err);
        }
      },
    });
  }

  /**
   * Read entire file into memory.
   * @returns {Promise<Buffer>}
   */
  async readToEnd() {
    const stream = this.createReadStream();
    return streamToBuffer(stream);
  }
}

/**
 * RarFilesPackage - parses multi-volume RAR archives.
 * 
 * Supports both native LocalFileMedia and custom FileMedia implementations
 * (like WebTorrent files). Custom implementations must have:
 * - name: string
 * - length: number
 * - createReadStream({ start, end }): Readable
 */
export class RarFilesPackage {
  constructor(files) {
    this._files = files;
    this._useNative = files.every(f => isNativeMedia(f));
    
    if (this._useNative) {
      const nativeFiles = files.map(f => f._nativeMedia ?? f._native ?? f);
      this._native = new NativeRarFilesPackage(nativeFiles);
    }
  }

  /**
   * Parse the archive and return inner files.
   * @param {{ maxFiles?: number }} [opts]
   * @returns {Promise<InnerFile[]>}
   */
  async parse(opts) {
    if (this._useNative) {
      const nativeFiles = await this._native.parse(opts);
      return nativeFiles.map(f => new InnerFile(f));
    }
    
    // JS-based parsing for custom FileMedia
    return this._parseJs(opts);
  }
  
  /**
   * JS-based parsing for custom FileMedia implementations.
   * @private
   */
  async _parseJs(opts) {
    const maxFiles = opts?.maxFiles;
    const results = [];
    
    for (const media of this._files) {
      // Read header data (first 512 bytes should be enough for header)
      const headerSize = Math.min(512, media.length);
      const headerStream = media.createReadStream({ start: 0, end: headerSize - 1 });
      const headerData = await streamToBuffer(headerStream);
      
      // Check signature
      if (!isRarArchive(headerData)) {
        continue;
      }
      
      // Determine RAR version
      const isRar5 = headerData.slice(0, 8).equals(RAR5_SIGNATURE);
      
      // Parse header to get file info
      const header = parseRarHeader(headerData);
      if (!header) {
        continue;
      }
      
      // Calculate data offset (approximate - after headers)
      // For RAR4: marker(7) + archive(13) + file header (variable)
      // For RAR5: signature(8) + headers (variable length)
      const dataOffset = media.length - header.packedSize;
      
      results.push(new JsInnerFile({
        name: header.name,
        packedSize: header.packedSize,
        unpackedSize: header.unpackedSize,
        method: header.method,
        dataOffset,
        media,
      }));
      
      if (maxFiles && results.length >= maxFiles) {
        break;
      }
    }
    
    return results;
  }
}
